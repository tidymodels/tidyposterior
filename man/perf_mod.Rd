% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/perf_mod.R
\name{perf_mod}
\alias{perf_mod}
\alias{perf_mod.rset}
\alias{perf_mod.resamples}
\alias{perf_mod.data.frame}
\alias{perf_mod.tune_results}
\alias{perf_mod.workflow_set}
\title{Bayesian Analysis of Resampling Statistics}
\usage{
perf_mod(object, ...)

\method{perf_mod}{rset}(object, transform = no_trans, hetero_var = FALSE, formula = NULL, ...)

\method{perf_mod}{resamples}(
  object,
  transform = no_trans,
  hetero_var = FALSE,
  metric = object$metrics[1],
  ...
)

\method{perf_mod}{data.frame}(object, transform = no_trans, hetero_var = FALSE, formula = NULL, ...)

\method{perf_mod}{tune_results}(
  object,
  metric = NULL,
  transform = no_trans,
  hetero_var = FALSE,
  formula = NULL,
  filter = NULL,
  ...
)

\method{perf_mod}{workflow_set}(
  object,
  metric = NULL,
  transform = no_trans,
  hetero_var = FALSE,
  formula = NULL,
  ...
)
}
\arguments{
\item{object}{Depending on the context:
\itemize{
\item A data frame with \code{id} columns for the resampling groupds and metric
results in all of the other columns..
\item An \code{rset} object (such as \code{\link[rsample:vfold_cv]{rsample::vfold_cv()}}) containing the \code{id}
column(s) and at least two numeric columns of model performance
statistics (e.g. accuracy).
\item An object from \code{caret::resamples}.
\item An object with class \code{tune_results}, which could be produced by
\code{tune::tune_grid()}, \code{tune::tune_bayes()} or similar.
\item A workflow set where all results contain the metric value given in the
\code{metric} argument value.
}}

\item{...}{Additional arguments to pass to \code{\link[rstanarm:stan_glmer]{rstanarm::stan_glmer()}} such as
\code{verbose}, \code{prior}, \code{seed}, \code{refresh}, \code{family}, etc.}

\item{transform}{An named list of transformation and inverse
transformation functions. See \code{\link[=logit_trans]{logit_trans()}} as an example.}

\item{hetero_var}{A logical; if \code{TRUE}, then different
variances are estimated for each model group. Otherwise, the
same variance is used for each group. Estimating heterogeneous
variances may slow or prevent convergence.}

\item{formula}{An optional model formula to use for the Bayesian hierarchical model
(see Details below).}

\item{metric}{A single character value for the statistic from
the \code{resamples} object that should be analyzed.}

\item{filter}{A conditional logic statement that can be used to filter the
statistics generated by \code{tune_results} using the tuning parameter values or
the \code{.config} column.}
}
\value{
An object of class \code{perf_mod}. If a workfkow set is given in
\code{object}, there is an extra class of \code{"perf_mod_workflow_set"}.
}
\description{
Bayesian analysis used here to answer the question: "when looking at
resampling results, are the differences between models 'real?'" To answer
this, a model can be created were the \emph{outcome} is the resampling statistics
(e.g. accuracy or RMSE). These values are explained by the model types. In
doing this, we can get parameter estimates for each model's affect on
performance and make statistical (and practical) comparisons between models.
}
\details{
These functions can be used to process and analyze matched
resampling statistics from different models using a Bayesian generalized
linear model with effects for the model and the resamples.
\subsection{Model formula}{

By default, a generalized linear model with Gaussian error and an identity
link is fit to the data and has terms for the predictive model grouping
variable. In this way, the performance metrics can be compared between
models.

Additionally, random effect terms are also used. For most resampling
methods (except repeated \emph{V}-fold cross-validation), a simple random
intercept model its used with an exchangeable (i.e. compound-symmetric)
variance structure. In the case of repeated cross-validation, two random
intercept terms are used; one for the repeat and another for the fold within
repeat. These also have exchangeable correlation structures.

The above model specification assumes that the variance in the performance
metrics is the same across models. However, this is unlikely to be true in
some cases. For example, for simple binomial accuracy, it well know that the
variance is highest when the accuracy is near 50 percent. When the argument
\code{hetero_var = TRUE}, the variance structure uses random intercepts for each
model term. This may produce more realistic posterior distributions but may
take more time to converge.

Examples of the default formulas are:

\preformatted{
 # One ID field and common variance:
   statistic ~ model + (model | id)

 # One ID field and heterogeneous variance:
   statistic ~ model + (model + 0 | id)

 # Repeated CV (id = repeat, id2 = fold within repeat)
 # with a common variance:
  statistic ~ model + (model | id2/id)

 # Repeated CV (id = repeat, id2 = fold within repeat)
 # with a heterogeneous variance:
  statistic ~ model + (model + 0| id2/id)

 # Default for unknown resampling method and
 # multiple ID fields:
  statistic ~ model + (model | idN/../id)
 }

Custom formulas should use \code{statistic} as the outcome variable and \code{model}
as the factor variable with the model names.

Also, as shown in the package vignettes, the Gaussian assumption make be
unrealistic. In this case, there are at least two approaches that can be
used. First, the outcome statistics can be transformed prior to fitting the
model. For example, for accuracy, the logit transformation can be used to
convert the outcome values to be on the real line and a model is fit to
these data. Once the posterior distributions are computed, the inverse
transformation can be used to put them back into the original units. The
\code{transform} argument can be used to do this.

The second approach would be to use a different error distribution from the
exponential family. For RMSE values, the Gamma distribution may produce
better results at the expense of model computational complexity. This can be
achieved by passing the \code{family} argument to \code{perf_mod} as one might with
the \code{glm} function.
}

\subsection{Workflow sets}{

Since workflow sets contain models and potentially sub-models, the
\code{perf_mod()} method for these types of objects will analyze the best
sub-model within each workflow (based on their \code{metric} value).
}
}
